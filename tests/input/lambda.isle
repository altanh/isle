; Ideally, we want something like
; (type E 
;   (enum (Var (name str))
;         (Lam (var str) (body E))
;         (App (func E) (arg E)))).
; But this is a recursive type so we would need to "box" the child Es.
(type E primitive)
(type str primitive)

(decl extern var (str) E)
(constructor var "MakeVar")
(extractor var "GetVar")

(decl extern lam (str E) E)
(constructor lam "MakeLam")
(extractor lam "GetLam")

(decl extern app (E E) E)
(constructor app "MakeApp")
(extractor app "GetApp")

(decl extern identity (E) E)
(constructor identity "Identity")

(decl subst (str E E) E)

(rule 3 (subst x e1 (var x)) (identity e1))

(rule 2 (subst x e1 (@ y (var yy))) (identity y))

;; shadowing
(rule 1 (subst x e1 (@ f (lam x e2))) (identity f))

(rule (subst x e1 (lam y e2)) (lam y (subst x e1 e2)))

(rule (subst x e1 (app f y)) (app (subst x e1 f) (subst x e1 y)))

;; eval

;; call-by-value
(decl eval_cbv (E) E)

(rule 2 (eval_cbv (app (lam x e) (@ g (lam _ _))))
  (eval_cbv (subst x g e)))

(rule 1 (eval_cbv (app (@ f (lam x e1)) e2))
  (eval_cbv (app f (eval_cbv e2))))

(rule 1 (eval_cbv (app f x))
  (eval_cbv (app (eval_cbv f) x)))

(rule (eval_cbv e)
  (identity e))

;; TODO broken

;; normal order
(decl eval_normal (E) E)

;; (\x.e1) e2 => e1[e2/x]

(rule 2 (eval_normal (app (lam x e) y)) (eval_normal (subst x y e)))

;; (rule 1 (eval_normal (app f x)) (eval_normal (app (eval_normal f) x)))

(rule (eval_normal (lam x e)) (lam x (eval_normal e)))

(rule (eval_normal e) (identity e))

(decl eval (E) E)
(rule (eval e) (eval_cbv e))
